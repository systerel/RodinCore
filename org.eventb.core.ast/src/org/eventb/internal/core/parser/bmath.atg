/*******************************************************************************
 * Copyright (c) 2005, 2009 ETH Zurich and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     ETH Zurich - initial API and implementation
 *     Systerel - mathematical language v2
 *     Systerel - added support for predicate variables
 *******************************************************************************/ 
import static org.eventb.core.ast.LanguageVersion.V1;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Stack;
import java.util.Vector;

import org.eventb.core.ast.ASTProblem;
import org.eventb.core.ast.Assignment;
import org.eventb.core.ast.BoundIdentDecl;
import org.eventb.core.ast.Expression;
import org.eventb.core.ast.Formula;
import org.eventb.core.ast.FormulaFactory;
import org.eventb.core.ast.FreeIdentifier;
import org.eventb.core.ast.Identifier;
import org.eventb.core.ast.IntegerLiteral;
import org.eventb.core.ast.LanguageVersion;
import org.eventb.core.ast.PowerSetType;
import org.eventb.core.ast.Predicate;
import org.eventb.core.ast.ProblemKind;
import org.eventb.core.ast.ProblemSeverities;
import org.eventb.core.ast.ProductType;
import org.eventb.core.ast.QuantifiedExpression;
import org.eventb.core.ast.SourceLocation;
import org.eventb.core.ast.Type;

COMPILER Bmath

	// Figures out whether we're at the beginning of a list of freeIdentifiers
	// containing at least two elements.
    private boolean isFreeIdentList() {
    	scanner.ResetPeek();
    	return la.kind == _IDENT && scanner.Peek().kind == _COMMA;
    }

	// Figures out whether we're at the beginning of a list of bound identifier
	// declarations.
    private boolean isIdentDeclList() {
    	scanner.ResetPeek();
		int kind = la.kind;
    	if (kind == _LPAR) {
    		kind = scanner.Peek().kind;
    	}
    	if (kind != _IDENT) {
    		return false;
    	}
    	if (kind == _RPAR) {
    		kind = scanner.Peek().kind;
    	}
		kind = scanner.Peek().kind;
        return kind == _COMMA || kind == _QDOT || kind == _TYPING;
    }

    // Returns <code>true</code> if the lookahead token is a left parenthesis
    // that starts a predicate, <code>false</code> otherwise.
    private boolean isParPredicate() {
    	scanner.ResetPeek();

        if (la.kind != _LPAR) {
        	// Lookahead token is not a left parenthesis
        	return false;
        }
        
        int kind = scanner.Peek().kind;
        if (kind == _QUNION || kind == _QINTER || kind == _LAMBDA) {
        	// Short circuit: if the parenthesis starts a quantified expression,
        	// we know for sure that it contains only the whole expression, not
        	// a predicate.
        	return false;
        }
        
        // Skip to the matching right parenthesis
    	int parLvl = 1;
		while (parLvl != 0) {
        	if (kind == _LPAR) {
        		++ parLvl;
        	} else if (kind == _RPAR) {
        		-- parLvl;
        	} else if (kind == _EOF) {
        		// Unbalanced parenthesis! Just return any value.
        		return false;
        	}
        	kind = scanner.Peek().kind;
		}
        
        // Now, let's look at the token that follows the right parenthesis
        switch (kind) {
        	case _EOF:
        	case _MID:
        	case _RPAR:
        	case _RBRACE:
			case _LAND:
			case _LOR:
			case _LEQV:
			case _LIMP:
        		return true;
        	default:
        		return false;
        }
    }

	// Returns true iff the next two tokens are a generic operator and TYPING
	private boolean isTypedGeneric() {
		scanner.ResetPeek();
		return isGeneric() && scanner.Peek().kind == _TYPING;	
	}

	private boolean isGeneric() {
		switch (la.kind) {
		case _EMPTYSET:
		case _KID:
		case _KPRJ1:
		case _KPRJ2:
			return true;
		default:
			return false;
		}
	}

	private boolean isValidTypedGeneric(int tag, Type type) {
		switch(tag) {
		case Formula.EMPTYSET:
			return (type instanceof PowerSetType);
		case Formula.KID_GEN:
			final Type source = type.getSource();
			return source != null && source.equals(type.getTarget());
		case Formula.KPRJ1_GEN:
			return isValidPrjType(type, true);
		case Formula.KPRJ2_GEN:
			return isValidPrjType(type, false);
		default:
			assert false;
			return false;
		}
	}
	
	private static boolean isValidPrjType(Type type, boolean left) {
		final Type source = type.getSource();
		final Type target = type.getTarget();
		if (!(source instanceof ProductType)) {
			return false;
		}

		final ProductType prodSource = (ProductType) source;
		final Type child;
		if (left) {
			child = prodSource.getLeft();
		} else {
			child = prodSource.getRight();
		}
		return target.equals(child);
	}

	// Figures out if the left brace just read starts a comprehension set.  For
	// that, we search for a matching MID symbol, taking into account the other
	// quantified expressions that can appear inside the braces.
	private boolean isComprehensionSet() {
		scanner.ResetPeek();
		int kind = la.kind;
		int parLvl = 0;
		int innerQuantifiedExpressions = 0;
		while (true) {
			if (kind == _LBRACE || kind == _LPAR) {
				++ parLvl;
			}
			else if (kind == _RBRACE || kind == _RPAR) {
				-- parLvl;
				if (parLvl < 0) {
					// We've gone past the closing brace.
					return false;
				}
			}
			else if (parLvl == 0) {
				if (kind == _LAMBDA || kind == _QUNION || kind == _QINTER) {
					++ innerQuantifiedExpressions;
				}
				else if (kind == _MID) {
					-- innerQuantifiedExpressions;
					if (innerQuantifiedExpressions < 0) {
						return true;
					}
				}
			}
			if (kind == _EOF) {
				// Unbalanced parentheses.
				return false;
			}
			kind = scanner.Peek().kind;
		}
	}

    // this class is immutable
    // represent a quantifier together with its bound identifiers and starting position.
    // used for a QuantifiedPredicate when parsing sequences of 
    // quantifiers (e.g. FORALL x,y EXISTS z)
    private static class Quantifier {
        final int tag;
        final List<BoundIdentDecl> boundIdentifiers;
        final int startPos;
        
        Quantifier(int tag, List<BoundIdentDecl> boundIdentifiers, int startPos) {
            this.tag = tag;
            this.boundIdentifiers = boundIdentifiers;
            this.startPos = startPos;
        }
    }
    
    private class Binding {
    	private HashMap<String, Integer> binders;
    	private int maxCount = -1;
 
    	// Creates an empty binding.
        Binding() {
        	binders = new HashMap<String, Integer>();
        }
    	
        // Creates a new binding based on <code>base</code> and extended
        // with <code>ident</code>
		Binding(Binding base, BoundIdentDecl ident) {
        	binders = new HashMap<String, Integer>(base.binders);
			maxCount = base.maxCount;
    		binders.put(ident.getName(), ++ maxCount);
    	}

        // Creates a new binding based on <code>base</code> and extended
        // with <code>idents</code>
		Binding(Binding base, List<BoundIdentDecl> idents) {
        	binders = new HashMap<String, Integer>(base.binders);
			int index = base.maxCount;
    		for (BoundIdentDecl ident: idents) {
    			binders.put(ident.getName(), ++ index);
    		}
    		maxCount = index;
    	}

		// Returns the index to use for the identifier <code>name</code>
		// or -1 if the name is free under this binding.
		int getBoundIndex(String name) {
			Integer index = binders.get(name);
			if (index == null) {
				return -1;
			}
			else {
				return maxCount - index;
			}
		}
    }

 
    // Creates an identifier for the given token.
    //
    // Takes care of the bindings.
    private Identifier makeIdent(Token token, Binding binding) {
    	int index = binding.getBoundIndex(token.val);
    	SourceLocation loc = new SourceLocation(token.pos, token.getEnd(),
    			result.getOrigin());
    	if (index == -1) {
			return factory.makeFreeIdentifier(token.val, loc);
    	}
    	else {
        	return factory.makeBoundIdentifier(index, loc);
		}
    }

    // Creates an identifier for the given token.
    private FreeIdentifier makeIdent(Token token) {
    	SourceLocation loc = new SourceLocation(token.pos, token.getEnd(),
    			result.getOrigin());
		return factory.makeFreeIdentifier(token.val, loc);
    }

	private BoundIdentDecl makePrimedDecl(FreeIdentifier ident) {
    	final String name = ident.getName();
    	final SourceLocation loc = ident.getSourceLocation();
		return factory.makeBoundIdentDecl(name + '\'', loc);
	}

	private List<BoundIdentDecl> makePrimedDecl(List<FreeIdentifier> lhsList) {
		final List<BoundIdentDecl> decls = new ArrayList<BoundIdentDecl>(lhsList.size());
	    for (FreeIdentifier ident: lhsList) {
			decls.add(makePrimedDecl(ident));
		}
		return decls;
	}

	private void checkSameLength(List<FreeIdentifier> lhsList,
			List<Expression> exprs, Token token) {

		final int lhsSize = lhsList.size();
		final int exprSize = exprs.size();
		String msg;
		if (lhsSize == exprSize)
			return;
		else if (lhsSize < exprSize)
			msg = "Too many expressions";
		else
			msg = "Too few expressions";

		result.addProblem(new ASTProblem(
				new SourceLocation(token.pos, token.getEnd(), result.getOrigin()),
				ProblemKind.SyntaxError, 
				ProblemSeverities.Error, 
				msg));
		throw new ParserException(msg);
	}

	private Expression makeFunctionOverriding(FreeIdentifier ident,
			Expression index, Expression value) {
		
		Expression pair = factory.makeBinaryExpression(Formula.MAPSTO, index, value, null);
		Expression singletonSet = factory.makeSetExtension(pair, null);
		return factory.makeAssociativeExpression(Formula.OVR, 
				new Expression[] {ident, singletonSet}, null);
	}

	private SourceLocation newSourceLoc(int startPos) {
		return new SourceLocation(startPos, t.getEnd(), result.getOrigin());
	}

	private Expression reduceAssociativeList(int tag,
			List<Expression> exprList, SourceLocation loc) {

		final Expression expr;
		if (exprList.size() == 1) {
			expr = exprList.get(0);
		} else {
			expr = factory.makeAssociativeExpression(Formula.PLUS, exprList, loc);
		}
		exprList.clear();
		return expr;
	}

	private ParserException unexpectedLPARInDeclList() {
		final SourceLocation loc = new SourceLocation(t.pos, t.pos, result.getOrigin());
		final ASTProblem problem = new ASTProblem(
				loc,
				ProblemKind.UnexpectedLPARInDeclList,
				ProblemSeverities.Error);
		result.addProblem(problem);
		return new ParserException("Unexpected left parenthesis.");
	}

	private void unexpectedPREDVAROccurence(int startPos) {
		SourceLocation loc = newSourceLoc(startPos);
		final ASTProblem problem = new ASTProblem(
				loc,
				ProblemKind.PredicateVariableNotAllowed,
				ProblemSeverities.Error,
				t.val);
		result.addProblem(problem);
	}

	private Expression makeUNMINUS(int startPos, Expression expr) {
		final SourceLocation loc = newSourceLoc(startPos);
        if (expr instanceof IntegerLiteral
        		&& expr.getSourceLocation().getStart() == startPos + 1) {
			// A unary minus followed by an integer literalm glued together,
			// this is a negative integer literal
        	final IntegerLiteral lit = (IntegerLiteral) expr;
        	return factory.makeIntegerLiteral(lit.getValue().negate(), loc);
        }
  		return factory.makeUnaryExpression(Formula.UNMINUS, expr, loc);
	}

	// For testing purposes
	public static int getPartitionT() {
		return _KPARTITION;
	}

	public static int getIdentT() {
		return _IDENT;
	}

TOKENS

	LPAR
	RPAR
	LBRACKET
	RBRACKET
	LBRACE
	RBRACE
	EXPN
	NOT
	CPROD
	LAMBDA
	UPTO
	NATURAL
	NATURAL1
	POW
	POW1
	INTEGER
	TFUN
	REL
	TSUR
	TINJ
	MAPSTO
	LIMP
	LEQV
	PFUN
	FORALL
	EXISTS
	EMPTYSET
	IN
	NOTIN
	SETMINUS
	MUL
	BCOMP
	PPROD
	LAND
	LOR
	BINTER
	BUNION
	BECEQ
	BECMO
	BECST
	EQUAL		
	NOTEQUAL	
	LT			
	LE			
	GT			
	GE			
	SUBSET		
	NOTSUBSET	
	SUBSETEQ	
	NOTSUBSETEQ	
	DPROD
	BTRUE
	BFALSE
	QINTER
	QUNION
	QDOT
	RANRES
	DOMRES
	PSUR
	PINJ
	TBIJ
	DOMSUB
	RANSUB
	TREL
	SREL
	STREL
	OVR
	FCOMP
	COMMA
	PLUS
	MINUS
	DIV
	MID
	CONVERSE
	BOOL
	TRUE
	FALSE
	KPRED
	KSUCC
	MOD
	KBOOL
	KCARD
	KUNION
	KINTER
	KDOM
	KRAN
	KID
	KFINITE
	KPRJ1
	KPRJ2
	KMIN
	KMAX
	KPARTITION
	DOT
	IDENT
	INTLIT
	TYPING
	PREDVAR


PRODUCTIONS

    Bmath  =
        IF (clazz == Predicate.class)
        Predicate <out Predicate inpred, new Binding()>        (. result.setParsedPredicate(inpred); .)
    |
        IF (clazz == Expression.class)
        Expression <out Expression inexpr, new Binding()>      (. result.setParsedExpression(inexpr); .)
    |
        IF (clazz == Assignment.class)
        Assignment <out Assignment assignment, new Binding()>  (. result.setParsedAssignment(assignment); .)
    |
        // IF (clazz == Type.class)
        Type <out Type type>  								   (. result.setParsedType(type); .)
    .
    
    Assignment <out Assignment assignment, Binding binding>
                                                          (. final int startPos = la.pos;
    												         assignment = null; .)
    =
        IF (isFreeIdentList())
        FreeIdentList <out List<FreeIdentifier> lhsList>
        (
             BECST										  (. List<BoundIdentDecl> primed = makePrimedDecl(lhsList);
             												 binding = new Binding(binding, primed); .)
             Predicate <out Predicate pred, binding>	  (. final SourceLocation loc = newSourceLoc(startPos);
        												     assignment = factory.makeBecomesSuchThat(lhsList, primed, pred, loc); .)
        |
             BECEQ										  (. Token opToken = t; .)
             ExpressionList <out List<Expression> exprs,
                             binding>					  (. checkSameLength(lhsList, exprs, opToken);
                             								 final SourceLocation loc = newSourceLoc(startPos);
                             								 assignment = factory.makeBecomesEqualTo(lhsList, exprs, loc); .)
        )
    |        
        IDENT											  (. final FreeIdentifier ident = makeIdent(t); .)
        (
        	BECST										  (. BoundIdentDecl primed = makePrimedDecl(ident);
             												 binding = new Binding(binding, primed); .)
        	Predicate <out Predicate pred, binding>		  (. final SourceLocation loc = newSourceLoc(startPos);
        												     assignment = factory.makeBecomesSuchThat(ident, primed, pred, loc); .)
        |
        	BECMO
        	Expression <out Expression expr, binding>	  (. final SourceLocation loc = newSourceLoc(startPos);
        												     assignment = factory.makeBecomesMemberOf(ident, expr, loc); .)
        |
        	BECEQ
        	Expression <out Expression expr, binding>	  (. final SourceLocation loc = newSourceLoc(startPos);
        												     assignment = factory.makeBecomesEqualTo(ident, expr, loc); .)
        |
        	LPAR
        	Expression <out Expression index, binding>
        	RPAR
        	BECEQ
        	Expression <out Expression expr, binding>	  (. final SourceLocation loc = newSourceLoc(startPos);
        													 expr = makeFunctionOverriding(ident, index, expr);
        													 assignment = factory.makeBecomesEqualTo(ident, expr, loc); .)
        )
    .

    ExpressionList <out List<Expression> exprs, Binding binding> 
    =                             					(. exprs = new ArrayList<Expression>(); .)
		Expression <out Expression expr, binding>   (. exprs.add(expr); .)
        {
        	COMMA
            Expression <out expr, binding>          (. exprs.add(expr); .)
       	}
    .

    Expression <out Expression expr, Binding binding>        (. final int startPos = la.pos;
                												expr = null; .)    
    =
        LAMBDA                                               (. List<BoundIdentDecl> inbinding;
                                                                Expression inpattern;
                                                                Predicate inpred;
                                                                Expression inexpr; .)
        DeclPattern <out inpattern>                          (. // LAMBDA implicit quantifier
                                                                inbinding = new Vector<BoundIdentDecl>();
                                                                inpattern = inpattern.bindAllFreeIdents(inbinding, factory);
                                                                binding = new Binding(binding, inbinding); .)
        QDOT
        Predicate <out inpred, binding>
        MID
        Expression <out inexpr, binding>                     (. Expression pair = factory.makeBinaryExpression(Formula.MAPSTO, inpattern, inexpr, null);
        														SourceLocation loc = newSourceLoc(startPos);
                                                                expr = factory.makeQuantifiedExpression(Formula.CSET, inbinding, inpred, pair, loc, QuantifiedExpression.Form.Lambda); .)
    |                                                        (. int tag;
                                                                QuantifiedExpression.Form form = null;
                                                                List<BoundIdentDecl> inbinding = null;
                                                                Predicate inpred = null;
                                                                Expression inexpr = null; .)
        (	QUNION                                           (. tag = Formula.QUNION; .)
        |	QINTER                                           (. tag = Formula.QINTER; .)
        )
        (
            IF (isIdentDeclList())                           (. form = QuantifiedExpression.Form.Explicit; .)
            DeclList <out inbinding>                         (. binding = new Binding(binding, inbinding); .)
            QDOT
            Predicate <out inpred, binding>
            MID
            Expression <out inexpr, binding>
        |
            Expression <out inexpr, new Binding()>
            MID                                              (. form = QuantifiedExpression.Form.Implicit;
                                                                inbinding = new Vector<BoundIdentDecl>();
                                                                inexpr = inexpr.bindAllFreeIdents(inbinding, factory);
                                                                binding = new Binding(binding, inbinding); .)
            Predicate <out inpred, binding>
        )                                                    (. SourceLocation loc = newSourceLoc(startPos);
            													expr = factory.makeQuantifiedExpression(tag, inbinding, inpred, inexpr, loc, form); .)
    |
        PairExpression <out expr, binding>
    .
    
    PairExpression <out Expression expr, Binding binding>    (. int startPos = la.pos; .)
    =
        RelationSetExpr <out expr, binding>
        {
            MAPSTO
            RelationSetExpr <out Expression inexpr, binding> (. SourceLocation loc = newSourceLoc(startPos);
            													expr = factory.makeBinaryExpression(Formula.MAPSTO, expr, inexpr, loc); .)
        }
    .
    
    RelationSetExpr <out Expression expr, Binding binding>   (. int startPos = la.pos; .)
    = 
       	SetExpr <out expr, binding>
    	(
    		IF (version == V1)
    	    {
        	    RelationalSetOp <out int tag>                        
            	SetExpr <out Expression inexpr, binding>         (. SourceLocation loc = newSourceLoc(startPos);
	                                                                expr = factory.makeBinaryExpression(tag, expr, inexpr, loc); .)
            }
	    |
    	    [
        	    RelationalSetOp <out int tag>                        
            	SetExpr <out Expression inexpr, binding>         (. SourceLocation loc = newSourceLoc(startPos);
	                                                                expr = factory.makeBinaryExpression(tag, expr, inexpr, loc); .)
		    ]
		)
    .
    
    RelationalSetOp <out int tag>
                                (. tag = -1; .)
    = REL                       (. tag = Formula.REL; .)
    | TREL                      (. tag = Formula.TREL; .)
    | SREL                      (. tag = Formula.SREL; .)
    | STREL                     (. tag = Formula.STREL; .)
    | PFUN                      (. tag = Formula.PFUN; .)
    | TFUN                      (. tag = Formula.TFUN; .)
    | PINJ                      (. tag = Formula.PINJ; .)
    | TINJ                      (. tag = Formula.TINJ; .)
    | PSUR                      (. tag = Formula.PSUR; .)
    | TSUR                      (. tag = Formula.TSUR; .)
    | TBIJ                      (. tag = Formula.TBIJ; .)
    .   
    
    SetExpr <out Expression expr, Binding binding>    (. final int startPos = la.pos;
                                                          List<Expression> exprList;
                                                          Expression inexpr; .)
    =
        IntervalExpr <out expr, binding>
        (
            BUNION                                     (. exprList = new ArrayList<Expression>();
                                                          exprList.add(expr); .)
            IntervalExpr <out expr, binding>           (. exprList.add(expr); .)
            {
                BUNION
                IntervalExpr <out expr, binding>       (. exprList.add(expr); .)
            }
                                                       (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeAssociativeExpression(Formula.BUNION, exprList, loc); .)
        |
            CPROD
            IntervalExpr <out inexpr, binding>         (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(Formula.CPROD, expr, inexpr, loc); .)
            {
                CPROD
                IntervalExpr <out inexpr, binding>     (. loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(Formula.CPROD, expr, inexpr, loc); .)
            }
        |
            OVR                                        (. exprList = new ArrayList<Expression>();
                                                          exprList.add(expr); .)
            IntervalExpr <out expr, binding>           (. exprList.add(expr); .)
            {
                OVR
                IntervalExpr <out expr, binding>       (. exprList.add(expr); .)
            }
                                                       (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeAssociativeExpression(Formula.OVR, exprList, loc); .)
        |
            BCOMP                                      (. exprList = new ArrayList<Expression>(); .)
                                                       (. exprList.add(expr); .)
            IntervalExpr <out expr, binding>           (. exprList.add(expr); .)
            {
                BCOMP
                IntervalExpr <out expr, binding>       (. exprList.add(expr); .)
            }
                                                       (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeAssociativeExpression(Formula.BCOMP, exprList, loc); .)

        |
            PPROD
            IntervalExpr <out inexpr, binding>         (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(Formula.PPROD, expr, inexpr, loc); .)
        |
            [                                          (. int tag; .)
                (
                    DOMRES                             (. tag = Formula.DOMRES; .)
                |
                    DOMSUB                             (. tag = Formula.DOMSUB; .)
                )
                IntervalExpr <out inexpr, binding>     (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(tag, expr, inexpr, loc); .)
            ]
            (
                DPROD
                IntervalExpr <out inexpr, binding>     (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(Formula.DPROD, expr, inexpr, loc); .)
            |
                FCOMP                                  (. exprList = new ArrayList<Expression>();
                                                          exprList.add(expr); .)
                IntervalExpr <out expr, binding>       (. exprList.add(expr); .)
                {
                    FCOMP
                    IntervalExpr <out expr, binding>   (. exprList.add(expr); .)
                }
                                                       (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeAssociativeExpression(Formula.FCOMP, exprList, loc); .)                
                [
                    RangeModifier <out int tag>
                    IntervalExpr <out inexpr, binding> (. loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(tag, expr, inexpr, loc); .)
                ]
            |
                BINTER                                 (. exprList = new ArrayList<Expression>();
                                                          exprList.add(expr); .)
                IntervalExpr <out expr, binding>       (. exprList.add(expr); .)
                {
                    BINTER
                    IntervalExpr <out expr, binding>   (. exprList.add(expr); .)
                }
                                                       (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeAssociativeExpression(Formula.BINTER, exprList, loc); .)
                [
                    SETMINUS
                    IntervalExpr <out inexpr, binding> (. loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(Formula.SETMINUS, expr, inexpr, loc); .)
                |
                    RangeModifier <out int tag>
                    IntervalExpr <out inexpr, binding> (. loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(tag, expr, inexpr, loc); .)
                ]
            |
                SETMINUS
                IntervalExpr <out inexpr, binding>     (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(Formula.SETMINUS, expr, inexpr, loc); .)
            |
                RangeModifier <out int tag>
                IntervalExpr <out inexpr, binding>     (. SourceLocation loc = newSourceLoc(startPos);
            											  expr = factory.makeBinaryExpression(tag, expr, inexpr, loc); .)
            |
                /* Nothing */
            )
        )
    .

    RangeModifier <out int tag>
                              (. tag = -1; .)
    = RANRES                  (. tag = Formula.RANRES; .)
    | RANSUB                  (. tag = Formula.RANSUB; .)
    .
    
    IntervalExpr <out Expression expr, Binding binding> (. final int startPos = la.pos; 
    													   Expression inexpr; .)
    =
        ArithmeticExpr <out expr, binding>
        [
            UPTO
            ArithmeticExpr <out inexpr, binding>        (. SourceLocation loc = newSourceLoc(startPos);
            											   expr = factory.makeBinaryExpression(Formula.UPTO, expr, inexpr, loc); .)
        ]
    .
    
    ArithmeticExpr <out Expression expr, Binding binding> 
    =                                                (. final int startPos = la.pos;
                                                        boolean uminus = false; .)
        [
            MINUS									 (.	uminus = true; .)
        ]
        Term <out expr, binding>                     (.	if (uminus) {
                                                            expr = makeUNMINUS(startPos, expr);
                                                        } .)
        (
													 (. List<Expression> exprList = new ArrayList<Expression>();
            										    exprList.add(expr);
            											int endPos = t.getEnd(); .)
            {
               	PLUS
				Term <out expr, binding>             (. exprList.add(expr);
				                                        endPos = t.getEnd(); .)
			|
				MINUS
				Term <out expr, binding>             (. SourceLocation loc = new SourceLocation(startPos, endPos, result.getOrigin());
                                                        final Expression lhs = reduceAssociativeList(Formula.PLUS, exprList, loc);
                                                        loc = newSourceLoc(startPos);
                                                        exprList.add(factory.makeBinaryExpression(Formula.MINUS, lhs, expr, loc)); .)
            }
                                                     (. SourceLocation loc = newSourceLoc(startPos);
                                                        expr = reduceAssociativeList(Formula.PLUS, exprList, loc); .)
        )
    .
    
    Term <out Expression expr, Binding binding>     (. final int startPos = la.pos; 
                                                       Expression inexpr; .)
    =
        Factor <out expr, binding>
        (
            [                                       (. int tag; .)
                (
                    DIV                             (. tag = Formula.DIV; .)
                |
                    MOD                             (. tag = Formula.MOD; .)
                )
                Factor <out inexpr, binding>        (. SourceLocation loc = newSourceLoc(startPos);
            										   expr = factory.makeBinaryExpression(tag, expr, inexpr, loc); .)
            ]
        |
            MUL                                     (. List<Expression> exprList = new ArrayList<Expression>();
                                                       exprList.add(expr); .)
            Factor <out expr, binding>              (. exprList.add(expr); .)
            {
                MUL                                 
                Factor <out expr, binding>          (. exprList.add(expr); .)         
            }
                                                    (. SourceLocation loc = newSourceLoc(startPos);
            										   expr = factory.makeAssociativeExpression(Formula.MUL, exprList, loc); .)
        )
    .
    
    Factor <out Expression expr, Binding binding> (. final int startPos = la.pos;
                                                     Expression inexpr; .)
    
    =
		Image <out expr, binding>
        [
            EXPN
            Image <out inexpr, binding>           (. SourceLocation loc = newSourceLoc(startPos);
            										 expr = factory.makeBinaryExpression(Formula.EXPN, expr, inexpr, loc); .)
        ]
    .
    
    Image <out Expression expr, Binding binding>      (. final int startPos = la.pos;
                                                         Expression inexpr; .)
    =
        Primary <out expr, binding>
        {
            LBRACKET
            Expression <out inexpr, binding>
            RBRACKET                                  (. expr = factory.makeBinaryExpression(Formula.RELIMAGE, expr, inexpr, newSourceLoc(startPos)); .)
        |
            LPAR
            Expression <out inexpr, binding>
            RPAR                                      (. expr = factory.makeBinaryExpression(Formula.FUNIMAGE, expr, inexpr, newSourceLoc(startPos)); .)
        }
    .
    
    Primary <out Expression expr, Binding binding>       (. final int startPos = la.pos; .)
    =
        SimpleExpr <out expr, binding>
        {
            CONVERSE                                     (. expr = factory.makeUnaryExpression(Formula.CONVERSE, expr, newSourceLoc(startPos)); .)
        }
    .

    
    SimpleExpr <out Expression expr, Binding binding>    (. final int startPos = la.pos;
    														expr = null; .)
    =
        KBOOL
        LPAR
        Predicate <out Predicate inpred, binding>
        RPAR                                             (. expr = factory.makeBoolExpression(inpred, newSourceLoc(startPos)); .)
    |
        UnaryOp <out int tag>
        LPAR
        Expression <out expr, binding>
        RPAR                                             (. expr = factory.makeUnaryExpression(tag, expr, newSourceLoc(startPos)); .)
    |
    	(
    		IF (version == V1)
    		UnaryOrAtomicOp <out int tag>
    		LPAR
    		Expression <out expr, binding>
    		RPAR                             (. expr = factory.makeUnaryExpression(tag, expr, newSourceLoc(startPos)); .)
    	|
    		UnaryOrAtomicOp <out int tag>    (. expr = factory.makeAtomicExpression(tag, newSourceLoc(startPos)); .)
    	)
    |
        LPAR
        (
        	IF (isTypedGeneric())
                                          (. int tag = -1; .)
        	(
                 EMPTYSET                 (. tag = Formula.EMPTYSET; .)
            |    UnaryOrAtomicOp <out tag>
	        )
                 TYPING					  (. int typeStart = la.pos; .)
                 Type<out Type type>      (. if (! isValidTypedGeneric(tag, type)) {
                                                 final SourceLocation loc = newSourceLoc(typeStart);
                                                 result.addProblem(new ASTProblem(
                                                    loc,
                                                    ProblemKind.InvalidTypeExpression, 
                                                    ProblemSeverities.Error));
                                                 type = null;
                                             } .)
                 RPAR                     (. expr = factory.makeAtomicExpression(tag, newSourceLoc(startPos), type); .)
        |
	        Expression <out expr, binding>
			RPAR
	    )
    |
        LBRACE
       	(
    		IF (isComprehensionSet())                    (. QuantifiedExpression.Form form = null;
                                                            List<BoundIdentDecl> inbinding = null;
                                                            Expression inexpr = null;
                                                            Predicate inpred = null; .)
      		(
            	IF (isIdentDeclList())					 (. form = QuantifiedExpression.Form.Explicit; .)
            	DeclList <out inbinding>
            	                                         (. binding = new Binding(binding, inbinding); .)
            	QDOT
            	Predicate <out inpred, binding>
           		MID
            	Expression <out inexpr, binding>
       		|							                 (. form = QuantifiedExpression.Form.Implicit; .)
            	Expression <out inexpr, new Binding()>
            	MID                                      (. inbinding = new Vector<BoundIdentDecl>();
                                                            inexpr = inexpr.bindAllFreeIdents(inbinding, factory);
                                                            binding = new Binding(binding, inbinding); .)
            	Predicate <out inpred, binding>
        	)
       		RBRACE      								 (. SourceLocation loc = newSourceLoc(startPos);
                                                            expr = factory.makeQuantifiedExpression(Formula.CSET, inbinding, inpred, inexpr, loc, form); .)
        |                                                (. List<Expression> exprs = new ArrayList<Expression>(); .)
        	[
            	ExpressionList <out exprs, binding>
            ]
        	RBRACE                                       (. expr = factory.makeSetExtension(exprs, newSourceLoc(startPos)); .)
        )
    |
        INTEGER     (. expr = factory.makeAtomicExpression(Formula.INTEGER, newSourceLoc(t.pos)); .)
    |
        NATURAL     (. expr = factory.makeAtomicExpression(Formula.NATURAL, newSourceLoc(t.pos)); .)
    |
        NATURAL1    (. expr = factory.makeAtomicExpression(Formula.NATURAL1, newSourceLoc(t.pos)); .)
    |
        BOOL        (. expr = factory.makeAtomicExpression(Formula.BOOL, newSourceLoc(t.pos)); .)
    |
        TRUE        (. expr = factory.makeAtomicExpression(Formula.TRUE, newSourceLoc(t.pos)); .)
    |
        FALSE       (. expr = factory.makeAtomicExpression(Formula.FALSE, newSourceLoc(t.pos)); .) 
    |
        EMPTYSET    (. expr = factory.makeAtomicExpression(Formula.EMPTYSET, newSourceLoc(t.pos)); .)
    |
        KPRED       (. expr = factory.makeAtomicExpression(Formula.KPRED, newSourceLoc(t.pos)); .)
    |
        KSUCC       (. expr = factory.makeAtomicExpression(Formula.KSUCC, newSourceLoc(t.pos)); .)
    |
        IDENT       (. expr = makeIdent(t, binding); .)
    |
        INTLIT      (. expr =  factory.makeIntegerLiteral(new BigInteger(t.val), newSourceLoc(t.pos)); .)
    .

	
 	UnaryOrAtomicOp <out int tag>
                     (. tag = -1; .)
    =
	    IF (version == V1)
		(   KID	     (. tag = Formula.KID; .)
    	|	KPRJ1    (. tag = Formula.KPRJ1; .)
    	|	KPRJ2    (. tag = Formula.KPRJ2; .)
    	)
	|
		(   KID	     (. tag = Formula.KID_GEN; .)
    	|	KPRJ1    (. tag = Formula.KPRJ1_GEN; .)
    	|	KPRJ2    (. tag = Formula.KPRJ2_GEN; .)
    	)
    .
 
    UnaryOp <out int tag>
               (. tag = -1; .)
    = KCARD    (. tag = Formula.KCARD; .)
    | POW      (. tag = Formula.POW; .)
    | POW1     (. tag = Formula.POW1; .)
    | KUNION   (. tag = Formula.KUNION; .)
    | KINTER   (. tag = Formula.KINTER; .)
    | KDOM     (. tag = Formula.KDOM; .)
    | KRAN     (. tag = Formula.KRAN; .)
    | KMIN     (. tag = Formula.KMIN; .)
    | KMAX     (. tag = Formula.KMAX; .)
    .

    DeclList <out List<BoundIdentDecl> idents>
                                    (. idents = new Vector<BoundIdentDecl>();
    								   BoundIdentDecl decl; .)
    
    =        IdentDecl<out decl>	(. idents.add(decl); .)
        {
            COMMA
            IdentDecl<out decl>	    (. idents.add(decl); .)
        }
    |
    	LPAR                        (. throw unexpectedLPARInDeclList(); .)
    .

	IdentDecl <out BoundIdentDecl decl> (. Type type = null; .)
	=
		IDENT					        (. final Token identToken = t; .)
		[
			TYPING
			Type<out type>
		]						        (. final SourceLocation loc = newSourceLoc(identToken.pos);
									       decl = factory.makeBoundIdentDecl(identToken.val, loc, type); .)
	.

    FreeIdentList <out List<FreeIdentifier> idents> 
    =                             (. idents = new Vector<FreeIdentifier>(); .)
        IDENT                     (. idents.add(factory.makeFreeIdentifier(t.val, newSourceLoc(t.pos))); .)
        {
            COMMA
            IDENT                 (. idents.add(factory.makeFreeIdentifier(t.val, newSourceLoc(t.pos))); .)
        }
    .

    DeclPattern <out Expression expr>                (. final int startPos = la.pos; .)
    =
        DeclPatternAtom <out expr>
        {
            MAPSTO
            DeclPatternAtom <out Expression inexpr>  (. expr = factory.makeBinaryExpression(Formula.MAPSTO, expr, inexpr, newSourceLoc(startPos)); .)
        }
    .

    DeclPatternAtom <out Expression expr>     (. expr = null; .)
    =
        LPAR 
        DeclPattern <out expr>
        RPAR
    |
        IdentDecl<out BoundIdentDecl decl>    (. final String name = decl.getName();
        										 final SourceLocation loc = decl.getSourceLocation();
        										 final Type type = decl.getType();
										         expr = factory.makeFreeIdentifier(name, loc, type); .)
    .
    
    Predicate <out Predicate pred, Binding binding> 
    =                                                   (. // stack of parsed quantifiers
                                                           Stack<Quantifier> quantStack = new Stack<Quantifier>();
                                                           List<BoundIdentDecl> boundIdents; .)
        {
            FORALL                                      (. final int startPos = t.pos; .)
            DeclList<out boundIdents>                   (. binding = new Binding(binding, boundIdents);
                                                           quantStack.push(new Quantifier(Formula.FORALL, boundIdents, startPos)); .)
            QDOT
        |
            EXISTS                                      (. final int startPos = t.pos; .)
            DeclList<out boundIdents>                   (. binding = new Binding(binding, boundIdents);
                                                           quantStack.push(new Quantifier(Formula.EXISTS, boundIdents, startPos)); .)
            QDOT
        }
        UnquantifiedPredicate <out pred, binding>        (. while (! quantStack.isEmpty()) {
                                                               Quantifier quant = quantStack.pop();
                                                               final SourceLocation loc = newSourceLoc(quant.startPos);
                                                               pred = factory.makeQuantifiedPredicate(quant.tag, quant.boundIdentifiers, pred, loc);
                                                           } .)
    .

    UnquantifiedPredicate <out Predicate pred, Binding binding>
    =                                                 (. final int startPos = la.pos;
    													 Predicate inpred; .)
        SimplePredicate <out pred, binding>
        [
            LIMP
            SimplePredicate <out inpred, binding>     (. pred = factory.makeBinaryPredicate(Formula.LIMP, pred, inpred, newSourceLoc(startPos)); .)
        |
            LEQV
            SimplePredicate <out inpred, binding>     (. pred = factory.makeBinaryPredicate(Formula.LEQV, pred, inpred, newSourceLoc(startPos)); .)
        ]
    .
    
    SimplePredicate <out Predicate pred, Binding binding> 
    =                                                  (. final int startPos = la.pos;
    													  List<Predicate> predList; .)
        LiteralPredicate <out pred, binding>
        [
            LAND                                       (. predList = new ArrayList<Predicate>();
                                                          predList.add(pred); .)
            LiteralPredicate <out pred, binding>       (. predList.add(pred); .)
            {
                LAND
                LiteralPredicate <out pred, binding>   (. predList.add(pred); .)
            }                                          (. pred = factory.makeAssociativePredicate(Formula.LAND, predList, newSourceLoc(startPos)); .)
        |
            LOR                                        (. predList = new ArrayList<Predicate>();
                                                          predList.add(pred); .)
            LiteralPredicate <out pred, binding>       (. predList.add(pred); .)
            {
                LOR
                LiteralPredicate <out pred, binding>   (. predList.add(pred); .)
            }                                          (. pred = factory.makeAssociativePredicate(Formula.LOR, predList, newSourceLoc(startPos)); .)
        ]
    .
    
    LiteralPredicate <out Predicate pred, Binding binding> 
    =                                             (. // stack for keeping positions of NOT keywords
                                                     Stack<Integer> posStack = new Stack<Integer>(); .)
        {
            NOT                                   (. posStack.push(t.pos); .)
        }
        AtomicPredicate <out pred, binding>       (. while (! posStack.isEmpty()) {
                                                         final SourceLocation loc = newSourceLoc(posStack.pop());
                                                         pred = factory.makeUnaryPredicate(Formula.NOT, pred, loc); 
                                                     } .)
    .
    
    AtomicPredicate <out Predicate pred, Binding binding>
                                            (. final int startPos = la.pos;
                                               pred = null; .)
    =
        BFALSE                              (. pred = factory.makeLiteralPredicate(Formula.BFALSE, newSourceLoc(t.pos)); .)
    |
        BTRUE                               (. pred = factory.makeLiteralPredicate(Formula.BTRUE, newSourceLoc(t.pos)); .)
    |
    	PREDVAR								(. if (withPredVar) {
    											   final SourceLocation loc = newSourceLoc(startPos);
    					                           pred = factory.makePredicateVariable(t.val, loc);
    		                                   } else {
    		                                	  unexpectedPREDVAROccurence(startPos);
    		                                	  // Return a dummy value repairing temporarilly this error
    											  pred = factory.makeLiteralPredicate(Formula.BTRUE, newSourceLoc(t.pos));
    										   }
                                            .)        
    |
        KFINITE
        LPAR
        Expression <out Expression inexpr, binding>
        RPAR                                (. pred = factory.makeSimplePredicate(Formula.KFINITE, inexpr, newSourceLoc(startPos)); .)
    |
    	KPARTITION
   		LPAR
 		ExpressionList <out List<Expression> exprs, binding>
   		RPAR								(. pred = factory.makeMultiplePredicate(Formula.KPARTITION, exprs, newSourceLoc(startPos)); .)
    |
        IF (! isParPredicate())
        PairExpression <out Expression leftinexpr, binding>
        Relop <out int tag>
        PairExpression <out Expression rightinexpr, binding>
                                            (. pred = factory.makeRelationalPredicate(tag, leftinexpr, rightinexpr, newSourceLoc(startPos)); .)
    |
        LPAR
        Predicate <out pred, binding>
        RPAR
    .

    Relop <out int tag>
                  (. tag = -1; .) 
    = EQUAL       (. tag = Formula.EQUAL; .)
    | NOTEQUAL    (. tag = Formula.NOTEQUAL; .)
    | IN          (. tag = Formula.IN; .)
    | NOTIN       (. tag = Formula.NOTIN; .)
    | SUBSET      (. tag = Formula.SUBSET; .)
    | NOTSUBSET   (. tag = Formula.NOTSUBSET; .)
    | SUBSETEQ    (. tag = Formula.SUBSETEQ; .)
    | NOTSUBSETEQ (. tag = Formula.NOTSUBSETEQ; .)
    | LT          (. tag = Formula.LT; .)
    | LE          (. tag = Formula.LE; .)
    | GT          (. tag = Formula.GT; .)
    | GE          (. tag = Formula.GE; .)
    .

	Type<out Type type> =
		NotRelationalType<out type>
		[
			REL
			NotRelationalType<out Type inType>
					(. type = factory.makeRelationalType(type, inType); .)
		]
	.
	
	NotRelationalType<out Type type> =
        TypeFactor<out type>
		{
			CPROD
			TypeFactor<out Type inType>
			     (. type = factory.makeProductType(type, inType); .)
		}
	.

	TypeFactor<out Type type>
							(. type = null; .)
	=
		POW
		LPAR
		Type<out type>		(. type = factory.makePowerSetType(type); .)
		RPAR
	|	INTEGER				(. type = factory.makeIntegerType(); .)
	|	BOOL				(. type = factory.makeBooleanType(); .)
	|	IDENT				(. type = factory.makeGivenType(t.val); .)
	|	LPAR
		Type<out type>
		RPAR
	.

END Bmath.